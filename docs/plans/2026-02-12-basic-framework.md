# Prism Publisher Basic Framework Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the foundational plugin structure with platform adapter interface, authentication management, and Frontmatter handling for Obsidian multi-platform publishing.

**Architecture:** Modular TypeScript plugin with 5 core components: Platform Adapters (interface-based), Auth Manager (OAuth token storage), Content Converter (Markdown transformation), Queue Manager (priority-based publishing queue), Status Tracker (Frontmatter metadata). Each platform independently implements the PlatformAdapter interface.

**Tech Stack:** TypeScript, Obsidian Plugin API, Electron (for OAuth), axios (HTTP), js-yaml (Frontmatter), dayjs (time handling)

---

## Task 1: Initialize Obsidian Plugin Project Structure

**Files:**
- Create: `manifest.json`
- Create: `package.json`
- Create: `tsconfig.json`
- Create: `esbuild.config.mjs`
- Create: `main.ts`
- Create: `.github/workflows/release.yml`

**Step 1: Create package.json**

```bash
cat > package.json << 'EOF'
{
  "name": "obsidian-prism-publisher",
  "version": "0.0.1",
  "description": "One-click publish to multiple platforms from Obsidian",
  "main": "main.js",
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
    "version": "node version-bump.mjs && git add manifest.json versions.json"
  },
  "keywords": ["obsidian", "publish", "multi-platform"],
  "author": "Prism Publisher Team",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@typescript-eslint/eslint-plugin": "^6.13.0",
    "@typescript-eslint/parser": "^6.13.0",
    "builtin-modules": "^3.3.0",
    "esbuild": "^0.19.0",
    "eslint": "^8.54.0",
    "obsidian": "^1.4.0",
    "tslib": "^2.6.0",
    "typescript": "^5.3.0"
  },
  "dependencies": {
    "axios": "^1.6.0",
    "dayjs": "^1.11.10",
    "js-yaml": "^4.1.0"
  }
}
EOF
```

**Step 2: Create tsconfig.json**

```bash
cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "baseUrl": ".",
    "inlineSourceMap": true,
    "inlineSources": true,
    "module": "ESNext",
    "target": "ES6",
    "allowJs": true,
    "noImplicitAny": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "isolatedModules": true,
    "strictNullChecks": true,
    "lib": ["DOM", "ES5", "ES6", "ES7"]
  },
  "include": ["**/*.ts"]
}
EOF
```

**Step 3: Create manifest.json**

```bash
cat > manifest.json << 'EOF'
{
  "id": "prism-publisher",
  "name": "Prism Publisher",
  "version": "0.0.1",
  "minAppVersion": "1.4.0",
  "description": "One-click publish to multiple platforms from Obsidian",
  "author": "Prism Publisher Team",
  "authorUrl": "https://github.com/yourusername/obsidian-prism-publisher",
  "isDesktopOnly": true
}
EOF
```

**Step 4: Create esbuild.config.mjs**

```bash
cat > esbuild.config.mjs << 'EOF'
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === 'production');

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
		...builtins],
	format: 'cjs',
	target: 'es2018',
	logLevel: "info",
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outfile: 'main.js',
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
EOF
```

**Step 5: Create main.ts skeleton**

```bash
cat > main.ts << 'EOF'
import { Plugin } from 'obsidian';

export default class PrismPublisherPlugin extends Plugin {
	async onload() {
		console.log('Loading Prism Publisher plugin');

		// Add ribbon icon
		this.addRibbonIcon('ðŸŒˆ', 'Prism Publisher', () => {
			console.log('Prism Publisher ribbon icon clicked');
		});

		// Add command
		this.addCommand({
			id: 'publish-to-platforms',
			name: 'Publish to platforms',
			callback: () => {
				console.log('Publish command triggered');
			}
		});
	}

	onunload() {
		console.log('Unloading Prism Publisher plugin');
	}
}
EOF
```

**Step 6: Create versions.json**

```bash
cat > versions.json << 'EOF'
{
	"0.0.1": "0.15.0"
}
EOF
```

**Step 7: Install dependencies**

```bash
npm install
```

Expected: `added X packages` message

**Step 8: Build the plugin**

```bash
npm run build
```

Expected: `main.js` file created successfully

**Step 9: Commit**

```bash
git add .
git commit -m "feat: initialize Obsidian plugin project structure

- Set up TypeScript, esbuild, and package.json
- Create basic plugin skeleton with ribbon icon and command
- Configure manifest and versions.json"
```

---

## Task 2: Create Type Definitions and Interfaces

**Files:**
- Create: `src/types/platform.ts`
- Create: `src/types/publish.ts`
- Create: `src/types/queue.ts`

**Step 1: Create platform types**

```bash
mkdir -p src/types
cat > src/types/platform.ts << 'EOF'
export interface PlatformAdapter {
	readonly name: string;
	authenticate(): Promise<boolean>;
	publish(content: PublishContent): Promise<PublishResult>;
	update(articleId: string, content: PublishContent): Promise<void>;
	convertMarkdown(markdown: string): string;
}

export interface PublishContent {
	title: string;
	markdown: string;
	frontmatter: Record<string, any>;
	images: LocalImage[];
}

export interface PublishResult {
	success: boolean;
	articleId?: string;
	url?: string;
	error?: string;
}

export interface LocalImage {
	path: string;
	caption?: string;
}

export type PlatformName = 'wechat' | 'zhihu' | 'juejin' | 'xiaohongshu' | 'yuque';
EOF
```

**Step 2: Create publish types**

```bash
cat > src/types/publish.ts << 'EOF'
export interface PublishConfig {
	platforms: PlatformConfig[];
	images: ImageConfig;
}

export interface PlatformConfig {
	name: string;
	enabled: boolean;
	priority: number;
}

export interface ImageConfig {
	cdn: string;
	uploaded: boolean;
	baseUrl: string;
}

export interface PublishStatus {
	[platformName: string]: PlatformStatus;
}

export interface PlatformStatus {
	status: 'pending' | 'publishing' | 'published' | 'failed';
	articleId?: string;
	url?: string;
	publishedAt?: string;
	updatedAt?: string;
	error?: string;
	retryCount?: number;
	lastAttempt?: string;
}
EOF
```

**Step 3: Create queue types**

```bash
cat > src/types/queue.ts << 'EOF'
export interface QueueItem {
	notePath: string;
	noteTitle: string;
	platforms: string[];
	priority: number;
	status: 'pending' | 'publishing' | 'completed' | 'failed';
	createdAt: string;
	scheduledAt?: string;
}

export interface PluginSettings {
	accounts: Record<string, AccountInfo>;
	imageCdn: ImageCdnConfig;
	publishQueue: QueueItem[];
}

export interface AccountInfo {
	accessToken: string;
	refreshToken: string;
	expiresAt: string;
	appId?: string;
	openid?: string;
}

export interface ImageCdnConfig {
	provider: string;
	qiniu?: {
		accessKey: string;
		secretKey: string;
		bucket: string;
		domain: string;
	};
}
EOF
```

**Step 4: Commit**

```bash
git add src/types/
git commit -m "feat: define core TypeScript interfaces

- PlatformAdapter interface for all platforms
- PublishContent, PublishResult types
- PublishConfig, PublishStatus types for Frontmatter
- QueueItem, PluginSettings types for plugin data"
```

---

## Task 3: Implement Frontmatter Manager

**Files:**
- Create: `src/managers/FrontmatterManager.ts`
- Create: `src/utils/yaml.ts`

**Step 1: Create YAML utility**

```bash
mkdir -p src/utils
cat > src/utils/yaml.ts << 'EOF'
import { parse, stringify } from 'js-yaml';

export function parseYamlFrontmatter(content: string): { frontmatter: Record<string, any>; body: string } {
	const match = content.match(/^---\n([\s\S]+?)\n---/);
	if (!match) {
		return { frontmatter: {}, body: content };
	}

	try {
		const frontmatter = parse(match[1]) as Record<string, any>;
		const body = content.slice(match[0].length);
		return { frontmatter, body };
	} catch (error) {
		console.error('Failed to parse YAML frontmatter:', error);
		return { frontmatter: {}, body: content };
	}
}

export function updateYamlFrontmatter(content: string, newFrontmatter: Record<string, any>): string {
	const { frontmatter, body } = parseYamlFrontmatter(content);
	const merged = { ...frontmatter, ...newFrontmatter };
	const yamlStr = stringify(merged);
	return `---\n${yamlStr}---\n${body}`;
}
EOF
```

**Step 2: Write failing test for FrontmatterManager**

```bash
mkdir -p tests/managers
cat > tests/managers/testFrontmatterManager.ts << 'EOF'
import { describe, it, expect } from '@jest/globals';
import { FrontmatterManager } from '../../src/managers/FrontmatterManager';

describe('FrontmatterManager', () => {
	it('should parse publish config from frontmatter', () => {
		const content = `---
title: Test Post
publish_config:
  platforms:
    - name: wechat
      enabled: true
      priority: 1
---
# Content here
`;
		const manager = new FrontmatterManager();
		const config = manager.parsePublishConfig(content);

		expect(config.platforms).toBeDefined();
		expect(config.platforms.length).toBe(1);
		expect(config.platforms[0].name).toBe('wechat');
	});

	it('should update publish status in frontmatter', () => {
		const content = `---
title: Test Post
---
# Content here
`;
		const manager = new FrontmatterManager();
		const updated = manager.updatePublishStatus(content, 'wechat', {
			status: 'published',
			articleId: 'wx_123',
			url: 'https://example.com/123'
		});

		expect(updated).toContain('publish_status:');
		expect(updated).toContain('wx_123');
	});
});
EOF
```

**Step 3: Run test to verify it fails**

```bash
npm install --save-dev jest @types/jest ts-jest
npx jest tests/managers/testFrontmatterManager.ts --no-coverage 2>&1 | head -20
```

Expected: `FAIL` with "FrontmatterManager not defined" error

**Step 4: Implement FrontmatterManager**

```bash
mkdir -p src/managers
cat > src/managers/FrontmatterManager.ts << 'EOF
import { parseYamlFrontmatter, updateYamlFrontmatter } from '../utils/yaml';
import { PublishConfig, PublishStatus } from '../types/publish';

export class FrontmatterManager {
	parsePublishConfig(content: string): PublishConfig {
		const { frontmatter } = parseYamlFrontmatter(content);
		return frontmatter.publish_config || {
			platforms: [],
			images: {
				cdn: '',
				uploaded: false,
				baseUrl: ''
			}
		};
	}

	parsePublishStatus(content: string): PublishStatus {
		const { frontmatter } = parseYamlFrontmatter(content);
		return frontmatter.publish_status || {};
	}

	updatePublishStatus(
		content: string,
		platform: string,
		status: any
	): string {
		const { frontmatter } = parseYamlFrontmatter(content);
		const currentStatus = frontmatter.publish_status || {};
		const updatedStatus = {
			...currentStatus,
			[platform]: { ...currentStatus[platform], ...status }
		};
		return updateYamlFrontmatter(content, {
			publish_status: updatedStatus
		});
	}

	updatePublishConfig(
		content: string,
		config: Partial<PublishConfig>
	): string {
		const { frontmatter } = parseYamlFrontmatter(content);
		const currentConfig = frontmatter.publish_config || {
			platforms: [],
			images: { cdn: '', uploaded: false, baseUrl: '' }
		};
		const updatedConfig = {
			...currentConfig,
			...config
		};
		return updateYamlFrontmatter(content, {
			publish_config: updatedConfig
		});
	}
}
EOF
```

**Step 5: Run test to verify it passes**

```bash
npx jest tests/managers/testFrontmatterManager.ts --no-coverage
```

Expected: `PASS` with all tests passing

**Step 6: Commit**

```bash
git add src/managers src/utils tests/
git commit -m "feat: implement FrontmatterManager with tests

- Add YAML parsing utilities
- Implement parsePublishConfig, parsePublishStatus
- Implement updatePublishStatus, updatePublishConfig
- Add Jest tests for core functionality"
```

---

## Task 4: Implement Settings Manager

**Files:**
- Create: `src/managers/SettingsManager.ts`

**Step 1: Write failing test for SettingsManager**

```bash
cat > tests/managers/testSettingsManager.ts << 'EOF'
import { describe, it, expect } from '@jest/globals';
import { SettingsManager } from '../../src/managers/SettingsManager';
import { PluginSettings } from '../../src/types/queue';

describe('SettingsManager', () => {
	it('should load empty settings by default', () => {
		const plugin = {
			loadData: async () => null
		} as any;

		const manager = new SettingsManager(plugin);
		const settings = manager.getSettings();

		expect(settings.accounts).toEqual({});
		expect(settings.publishQueue).toEqual([]);
	});

	it('should save settings', async () => {
		const mockSaveData = jest.fn().mockResolvedValue(undefined);
		const plugin = {
			loadData: async () => null,
			saveData: mockSaveData
		} as any;

		const manager = new SettingsManager(plugin);
		await manager.updateSettings({ accounts: { wechat: { accessToken: 'token' } } });

		expect(mockSaveData).toHaveBeenCalled();
	});

	it('should get account info for platform', () => {
		const settings: PluginSettings = {
			accounts: {
				wechat: {
					accessToken: 'test_token',
					refreshToken: 'refresh',
					expiresAt: '2025-12-31'
				}
			},
			imageCdn: { provider: 'qiniu' },
			publishQueue: []
		};

		const plugin = { loadData: async () => settings } as any;
		const manager = new SettingsManager(plugin);

		const account = manager.getAccount('wechat');
		expect(account?.accessToken).toBe('test_token');
	});
});
EOF
```

**Step 2: Run test to verify it fails**

```bash
npx jest tests/managers/testSettingsManager.ts --no-coverage 2>&1 | head -20
```

Expected: `FAIL` with "SettingsManager not defined" error

**Step 3: Implement SettingsManager**

```bash
cat > src/managers/SettingsManager.ts << 'EOF'
import { Plugin, Notice } from 'obsidian';
import { PluginSettings, AccountInfo, QueueItem } from '../types/queue';

const DEFAULT_SETTINGS: PluginSettings = {
	accounts: {},
	imageCdn: {
		provider: ''
	},
	publishQueue: []
};

export class SettingsManager {
	private settings: PluginSettings;

	constructor(private plugin: Plugin) {
		this.settings = { ...DEFAULT_SETTINGS };
	}

	async load(): Promise<void> {
		const data = await this.plugin.loadData();
		this.settings = data || { ...DEFAULT_SETTINGS };
	}

	async save(): Promise<void> {
		await this.plugin.saveData(this.settings);
	}

	getSettings(): PluginSettings {
		return this.settings;
	}

	async updateSettings(updates: Partial<PluginSettings>): Promise<void> {
		this.settings = {
			...this.settings,
			...updates
		};
		await this.save();
	}

	getAccount(platform: string): AccountInfo | undefined {
		return this.settings.accounts[platform];
	}

	async setAccount(platform: string, account: AccountInfo): Promise<void> {
		this.settings.accounts[platform] = account;
		await this.save();
	}

	async removeAccount(platform: string): Promise<void> {
		delete this.settings.accounts[platform];
		await this.save();
	}

	getQueue(): QueueItem[] {
		return this.settings.publishQueue;
	}

	async addToQueue(item: QueueItem): Promise<void> {
		this.settings.publishQueue.push(item);
		await this.save();
	}

	async removeFromQueue(notePath: string): Promise<void> {
		this.settings.publishQueue = this.settings.publishQueue.filter(
			item => item.notePath !== notePath
		);
		await this.save();
	}
}
EOF
```

**Step 4: Run test to verify it passes**

```bash
npx jest tests/managers/testSettingsManager.ts --no-coverage
```

Expected: `PASS` with all tests passing

**Step 5: Commit**

```bash
git add src/managers/SettingsManager.ts tests/managers/testSettingsManager.ts
git commit -m "feat: implement SettingsManager with tests

- Load and save plugin settings
- Manage account info per platform
- Manage publish queue
- Add comprehensive unit tests"
```

---

## Task 5: Create Base Platform Adapter

**Files:**
- Create: `src/adapters/BasePlatformAdapter.ts`

**Step 1: Write failing test for BasePlatformAdapter**

```bash
mkdir -p tests/adapters
cat > tests/adapters/testBasePlatformAdapter.ts << 'EOF'
import { describe, it, expect } from '@jest/globals';
import { BasePlatformAdapter } from '../../src/adapters/BasePlatformAdapter';

class TestAdapter extends BasePlatformAdapter {
	constructor() {
		super('test-platform');
	}

	async authenticate(): Promise<boolean> {
		return true;
	}

	async publish(): Promise<any> {
		return { success: true };
	}
}

describe('BasePlatformAdapter', () => {
	it('should return platform name', () => {
		const adapter = new TestAdapter();
		expect(adapter.name).toBe('test-platform');
	});

	it('should convert markdown', () => {
		const adapter = new TestAdapter();
		const html = adapter.convertMarkdown('# Test');
		expect(html).toContain('Test');
	});
});
EOF
```

**Step 2: Run test to verify it fails**

```bash
npx jest tests/adapters/testBasePlatformAdapter.ts --no-coverage 2>&1 | head -20
```

Expected: `FAIL` with "BasePlatformAdapter not defined" error

**Step 3: Implement BasePlatformAdapter**

```bash
mkdir -p src/adapters
cat > src/adapters/BasePlatformAdapter.ts << 'EOF'
import { PlatformAdapter, PublishContent, PublishResult } from '../types/platform';
import { Notice } from 'obsidian';

export abstract class BasePlatformAdapter implements PlatformAdapter {
	abstract readonly name: string;
	abstract authenticate(): Promise<boolean>;
	abstract publish(content: PublishContent): Promise<PublishResult>;
	abstract update(articleId: string, content: PublishContent): Promise<void>;

	convertMarkdown(markdown: string): string {
		// Basic markdown conversion - override in subclass
		return markdown
			.replace(/^# (.*$)/gim, '<h1>$1</h1>')
			.replace(/^## (.*$)/gim, '<h2>$1</h2>')
			.replace(/^### (.*$)/gim, '<h3>$1</h3>')
			.replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
			.replace(/\*(.*)\*/gim, '<em>$1</em>');
	}

	protected showNotice(message: string, timeout: number = 5000): void {
		new Notice(message, timeout);
	}
}
EOF
```

**Step 4: Run test to verify it passes**

```bash
npx jest tests/adapters/testBasePlatformAdapter.ts --no-coverage
```

Expected: `PASS` with all tests passing

**Step 5: Commit**

```bash
git add src/adapters tests/adapters
git commit -m "feat: implement BasePlatformAdapter with tests

- Abstract base class for all platform adapters
- Define common interface and utility methods
- Add basic Markdown conversion
- Add unit tests for base functionality"
```

---

## Task 6: Integrate Managers into Main Plugin

**Files:**
- Modify: `main.ts:1-100`

**Step 1: Update main.ts to use managers**

```bash
cat > main.ts << 'EOF'
import { Plugin, Notice } from 'obsidian';
import { SettingsManager } from './src/managers/SettingsManager';
import { FrontmatterManager } from './src/managers/FrontmatterManager';

export default class PrismPublisherPlugin extends Plugin {
	private settingsManager: SettingsManager;
	private frontmatterManager: FrontmatterManager;

	async onload() {
		console.log('Loading Prism Publisher plugin');

		// Initialize managers
		this.settingsManager = new SettingsManager(this);
		await this.settingsManager.load();

		this.frontmatterManager = new FrontmatterManager();

		// Add ribbon icon
		this.addRibbonIcon('ðŸŒˆ', 'Prism Publisher', () => {
			this.openQueueManager();
		});

		// Add publish command
		this.addCommand({
			id: 'publish-to-platforms',
			name: 'Publish to platforms',
			callback: () => {
				this.publishToPlatforms();
			}
		});

		// Add settings tab
		this.addSettingTab(new PrismPublisherSettingTab(this.app, this));
	}

	openQueueManager() {
		new Notice('Queue manager coming soon!');
	}

	async publishToPlatforms() {
		const activeFile = this.app.workspace.getActiveFile();
		if (!activeFile) {
			new Notice('No active file');
			return;
		}

		new Notice(`Preparing to publish: ${activeFile.basename}`);
		// TODO: Implement full publishing workflow
	}

	onunload() {
		console.log('Unloading Prism Publisher plugin');
	}

	getSettingsManager() {
		return this.settingsManager;
	}
}

import { App, PluginSettingTab, Setting } from 'obsidian';

class PrismPublisherSettingTab extends PluginSettingTab {
	plugin: PrismPublisherPlugin;

	constructor(app: App, plugin: PrismPublisherPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const { containerEl } = this;
		containerEl.empty();

		new Setting(containerEl)
			.setName('Account Management')
			.setHeading()
			.setDesc('Manage platform accounts');

		new Setting(containerEl)
			.setName('Platforms')
			.setDesc('Configure platform authentication (coming soon)')
			.addButton(button => button
				.setButtonText('Setup Accounts')
				.setDisabled(true));
	}
}
EOF
```

**Step 2: Build and verify**

```bash
npm run build
```

Expected: `main.js` created without errors

**Step 3: Commit**

```bash
git add main.ts
git commit -m "feat: integrate managers into main plugin

- Initialize SettingsManager on load
- Initialize FrontmatterManager
- Add basic publish command placeholder
- Add settings tab with account management UI"
```

---

## Task 7: Add Jest Configuration

**Files:**
- Create: `jest.config.js`
- Modify: `package.json:scripts`

**Step 1: Create Jest config**

```bash
cat > jest.config.js << 'EOF'
module.exports = {
	preset: 'ts-jest',
	testEnvironment: 'node',
	roots: ['<rootDir>/tests'],
	testMatch: ['**/*.ts'],
	moduleFileExtensions: ['ts', 'js', 'jsx', 'tsx', 'json', 'node'],
	collectCoverageFrom: [
		'src/**/*.ts',
		'!src/**/*.d.ts'
	]
};
EOF
```

**Step 2: Update package.json scripts**

```bash
npm pkg set scripts.test="jest"
npm pkg set scripts.test:watch="jest --watch"
npm pkg set scripts.test:coverage="jest --coverage"
```

**Step 3: Run all tests**

```bash
npm test
```

Expected: All tests pass (7 tests across 3 test files)

**Step 4: Commit**

```bash
git add jest.config.js package.json
git commit -m "test: configure Jest for TypeScript testing

- Add Jest configuration
- Add test scripts to package.json
- Verify all tests pass"
```

---

## Task 8: Create Documentation

**Files:**
- Create: `README.md`
- Create: `CONTRIBUTING.md`
- Create: `docs/ARCHITECTURE.md`

**Step 1: Update README.md**

```bash
cat > README.md << 'EOF'
# Obsidian Prism Publisher

ðŸŒˆ One-click publish to multiple platforms from Obsidian

## Features

- ðŸš€ **Multi-platform publishing**: Publish to WeChat, Zhihu, Juejin, Xiaohongshu, and Yuque
- ðŸ“Š **Lifecycle management**: Track publication status across all platforms
- ðŸ” **OAuth authentication**: Secure one-click authorization for each platform
- ðŸ“ **Frontmatter integration**: Configure and track publications in your notes
- ðŸŽ¯ **Priority queue**: Manage and schedule publications

## Installation

\`\`\`bash
# Using BRAT
1. Install BRAT plugin in Obsidian
2. Add this plugin: https://github.com/yourusername/obsidian-prism-publisher
\`\`\`

## Development

\`\`\`bash
# Install dependencies
npm install

# Build
npm run build

# Run tests
npm test
\`\`\`

## Documentation

- [Architecture](docs/ARCHITECTURE.md)
- [Design Document](docs/plans/2026-02-12-prism-publisher-design.md)
- [Implementation Plan](docs/plans/2026-02-12-basic-framework.md)

## License

MIT
EOF
```

**Step 2: Create CONTRIBUTING.md**

```bash
cat > CONTRIBUTING.md << 'EOF'
# Contributing to Prism Publisher

## Development Setup

1. Clone the repository
2. Install dependencies: `npm install`
3. Build: `npm run build`
4. Run tests: `npm test`

## Code Style

- Use TypeScript for all code
- Follow existing code patterns
- Write tests for new features (TDD)
- Commit frequently with descriptive messages

## Testing

- Unit tests in `tests/` directory
- Run `npm test` before committing
- Aim for high test coverage

## Pull Requests

1. Create a feature branch
2. Implement your changes
3. Add/update tests
4. Submit PR with clear description
EOF
```

**Step 3: Create ARCHITECTURE.md**

```bash
cat > docs/ARCHITECTURE.md << 'EOF'
# Prism Publisher Architecture

## Overview

Prism Publisher uses a modular architecture with 5 core components:

## Components

### 1. Platform Adapters
Each platform (WeChat, Zhihu, etc.) implements the `PlatformAdapter` interface:
- `authenticate()`: OAuth login flow
- `publish()`: Publish content
- `update()`: Update published article
- `convertMarkdown()`: Platform-specific Markdown transformation

### 2. Auth Manager
- Manages OAuth tokens for all platforms
- Stores encrypted tokens in plugin data
- Auto-refreshes expired tokens

### 3. Frontmatter Manager
- Parses and updates YAML frontmatter
- Reads `publish_config` and `publish_status`
- Updates publication metadata

### 4. Settings Manager
- Loads/saves plugin settings
- Manages account credentials
- Maintains publish queue

### 5. Queue Manager
- Priority-based publishing queue
- Drag-and-drop reordering
- Batch publishing support

## Data Flow

1. User selects platforms in publish panel
2. Frontmatter Manager reads config
3. Content Converter transforms Markdown
4. Queue Manager schedules publications
5. Platform Adapters publish in priority order
6. Status Tracker updates Frontmatter

## Type Definitions

All types defined in `src/types/`:
- `platform.ts`: Platform adapter interfaces
- `publish.ts`: Publish config and status types
- `queue.ts`: Queue and settings types
EOF
```

**Step 4: Commit**

```bash
git add README.md CONTRIBUTING.md docs/ARCHITECTURE.md
git commit -m "docs: add comprehensive documentation

- Update README with features and installation
- Add contributing guidelines
- Document architecture and components"
```

---

## Final Verification

**Step 1: Run full test suite**

```bash
npm test
```

Expected: All tests pass (7+ tests)

**Step 2: Build plugin**

```bash
npm run build
```

Expected: `main.js` created successfully

**Step 3: Check git status**

```bash
git status
```

Expected: `nothing to commit, working tree clean`

**Step 4: View commit history**

```bash
git log --oneline -10
```

Expected: 9 commits documenting all changes

---

## Summary

This plan implements the **Basic Framework** for Prism Publisher with:

âœ… **Project Structure**: TypeScript, esbuild, Jest
âœ… **Type Definitions**: Core interfaces for platforms, publishing, and queue
âœ… **Frontmatter Manager**: Parse and update YAML metadata
âœ… **Settings Manager**: Plugin data persistence
âœ… **Platform Adapter Base**: Abstract class for all platforms
âœ… **Plugin Integration**: Managers integrated into main plugin
âœ… **Testing**: Jest configuration and unit tests
âœ… **Documentation**: README, contributing guide, architecture doc

**Next Phase**: Implement individual platform adapters (WeChat, Zhihu, etc.)

---

**Estimated Time**: 3-4 hours for experienced developer

**Deliverables**:
- Working plugin structure
- 7 passing unit tests
- Comprehensive documentation
- Ready for platform adapter implementation
